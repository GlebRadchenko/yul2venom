Panic 0x32 Root Cause Analysis – Dispatcher, Memory, and Deduplication Issues
Dispatcher Branch Routing Failure (EOA vs Callback)

The Fallback._fallback logic is intended to distinguish between an EOA call and a contract callback by checking origin() == caller(). On a top-level (EOA) call, this flag should be true, causing an immediate branch to trade() and then returning. In the transpiled GuardedTrader, however, this dispatcher misbehaved – an EOA invocation erroneously flowed into the callback path. In other words, the external call was misrouted as if it were a Uniswap callback. This suggests a codegen bug where the condition or control flow for flag (the EOA check) was not respected. One possibility is that the transpiler’s optimizer inlined or merged code in a way that skipped the return trade(), allowing execution to fall through. For example, if the internal trade function was inlined and not properly terminated, the program counter could continue into the ProxyLib forward/callback section. Another risk is variable reuse or deduplication: the assembly uses a boolean flag in both _fallback and callback() (for different purposes), and an aggressive optimization might have merged or confused these paths. The result was the contract treating an EOA call as a callback, entering the callback() handler erroneously. In summary, the dispatcher’s branch logic failed – the function pointer jump went to the wrong branch – causing the GuardedTrader to invoke callback() when it should have executed trade(). This misrouting is the first critical failure in the chain.

“Ghost” Array and Uninitialized Memory Panic

Once the execution took the wrong path, the contract began processing data under false assumptions. In the EOA case, no Uniswap pair had called us, yet we entered the callback routine expecting swap callback parameters. The fallback’s assembly blindly attempted to parse msg.data as if it contained callback parameters (amounts and a bytes payload) when in fact msg.data was the encoded trade path. It treated segments of msg.data as amount0Delta, amount1Delta, and a data offset/length, then sliced out what it thought was the embedded data bytes (starting at offset 132). This is a catastrophic misinterpretation. In our scenario, the actual trade data was not nearly that long, so msg.data[132:] ended up being an empty or nonsensical slice. The Params.Data structure that gets decoded from this slice was essentially default-initialized – in particular, the dynamic path array inside it came out length-zero or filled with zeros. Thus we had a “ghost” array: a memory region (e.g. starting at address 0x160) reserved for the path that was never populated, because the normal trade() parsing never ran and the callback path’s decode was bogus.

Despite the array being empty, the code proceeded to use it. For example, the callback handler eventually does something analogous to initial = p.path[0] to retrieve the first step, without checking if the array has any elements. In our case the length was 0, so this access was out-of-bounds. Since Solidity inserts runtime checks for out-of-range array accesses, this triggered a Panic(0x32) – the standard EVM panic for array index out-of-bounds. Essentially, the transpiled code attempted to read from a memory pointer that was still zero (null) or pointing at an uninitialized array structure, violating memory layout assumptions. This null-pointer dereference manifested as the Panic 0x32 at runtime. The memory at that pointer was zeroed out by default and never written with valid data due to the earlier branch misrouting, hence the term “ghost array” – it was an array that should have held the trade path but remained empty and haunted the execution.

Root Cause: In the generated Yul/IR, the pointer to this data structure was initialized to zero by default outside of any safe context and only set to a real memory address inside a conditional block (the “success” path of an external call or the EOA branch). However, the code later accessed this pointer unconditionally, effectively bypassing the success/failure guard. This pattern can happen if the transpiler hoists a variable declaration or use beyond its proper scope. For instance, one might see pseudo-Yul like:

let expr_mpos := 0     // default to null
if call_success {
    expr_mpos := <allocated_memory_ptr>
    …  // (fill memory with data)
} 
// ... later ...
let value := mload(expr_mpos)  // ← used regardless of success

If the call_success was false (or the branch not taken due to the misroute), expr_mpos remains 0 and the mload(expr_mpos) reads from address 0. In our case that meant reading a length of 0 and proceeding into an out-of-bounds access. Native Solidity compiled code would never do this – it would either revert immediately on a failed call or only use the returned pointer within the if block. The transpiled GuardedTrader failed to enforce that, leading to a memory safety violation.

Memory Flow and Population Errors

We can delve deeper into how this situation arose in the transpiler’s memory handling. The yul2venom transpiler emits Yul/IR for dynamic memory allocation and data copying. Normally, when decoding the trade path, the code would allocate a new array in memory and copy each command from calldata into this array. For example, a Yul snippet to allocate a dynamic array might look like:

let memPtr := mload(64)                      // allocate array
let newFreePtr := add(memPtr, size)          
mstore(64, newFreePtr)                       
mstore(memPtr, length)                       // store array length
// allocate and zero-initialize each element pointer
for { let i := 0 } lt(i, length) { i := add(i, 1) } {
    let elemPtr := allocate_memory()        // allocate struct for element
    mstore(elemPtr, 0)                      
    mstore(add(elemPtr, 32), 0)             // zero init fields
    mstore(add(memPtr, mul(i, 32), 32), elemPtr)  // store pointer in array
}
… // later fill each element from calldata

In the correct EOA path, the Params.asParams logic does exactly this kind of work to populate params.path. However, in our failing execution path, none of this happened – the memory was never filled from calldata. The transpiler likely skipped the calldatacopy or calldataload operations that should have populated the array because the code never entered the branch that executes them. This is why the memory at 0x160 (where the path array was expected) remained all zeros. It’s a clear memory population failure: the contract should have copied the calldate (trade parameters) into memory structures but did not, due to the incorrect control flow.

Another contributing factor could be the optimizer’s aggressive removal of what it deemed “redundant” checks. If the Yul source had an if (failed_call) { revert … } around the memory access, an overly aggressive optimization might strip it out. Notably, the yul2venom tool has a “maximum” optimization level that removes overflow and bounds checks. The presence of Panic(0x32) suggests an array bounds check was relevant. It’s possible that at an unsafe optimization setting, the transpiler’s Yul source optimizer removed the bounds-check conditional, inadvertently allowing execution to continue with a zero length. (Indeed, the Yul optimizer explicitly targets patterns like panic_error_0x32() for elimination.) If such a check was optimized away, the code would no longer guard against out-of-range access – exactly the scenario we observed.

Function Deduplication and Label Merging Risks

During transpilation and linking, the system likely performs deduplication of identical code blocks to minimize bytecode size. However, there is a risk that structural helper functions or common code sequences get merged incorrectly across different contexts. For instance, auto-generated Yul functions for things like array index calculation (memory_array_index_access_*) or memory allocation might appear in both the init code and runtime code objects. If the linker naively merges them, a call intended for one context might jump to a function in another, messing up state or assumptions. In our case, we suspect something along these lines may have affected the fallback logic. The assembly in both the EOA handler and the Uniswap callback handler had similar structures (setting a flag and using switch/if), which could have been seen as a candidate for merging. If an optimizer deduplicated those, it might unify the two code paths that should remain distinct. This could explain how the EOA check ended up effectively using the wrong flag or branch – i.e. function pointer misrouting caused by merging what should have been separate branches. While we don’t have a smoking gun in the code for a merged label, the described symptoms (EOA flow jumping into callback) are consistent with such a mix-up.

Additionally, stack slot reuse or spills could play a role here. If the transpiler reused a register or stack location for multiple purposes across branches, it might clobber a flag or pointer. For example, the flag variable from the EOA check could have been stored in a slot that later got reused for something else (like the Uniswap address check flag) due to inlining. Or the pointer variable for the array might have been allocated in a register that was then overwritten before use. The Venom IR builder documentation highlights how fragile memory pointer handling can be – it implements a “Use-Before-Commit” pattern to avoid losing the free memory pointer on the stack. If such precautions failed (or if an allocation’s finalization overwrote a needed value), it could lead to using an outdated or zero pointer. In summary, memory/stack management bugs at the IR level – such as not preserving a pointer until its use or mistakenly merging lifetimes of variables – likely compounded the issue.

Conclusion – Synthesis of the Failures

In the transpiled GuardedTrader, multiple low-level issues converged to cause the Panic 0x32:

Control Flow Misrouting: The fallback dispatcher’s origin/caller check did not properly short-circuit to trade(). Instead, the execution fell through to the wrong branch, treating an EOA call as a liquidity-pool callback. This function-pointer mix-up appears to stem from improper code generation or aggressive deduping of similar code blocks, effectively merging separate execution paths that should remain isolated.

Uninitialized Memory Access: Because the code skipped the normal trade path, the critical setup of in-memory structures (the trade params and path array) never occurred. The transpiler still attempted to use these structures as if they were valid. A pointer that was default-initialized to 0 (null) was read without ensuring the external call/data that was supposed to set it had succeeded. This led to an out-of-bounds array access (length 0, index 0) and a resulting Panic(0x32). In essence, a memory layout violation occurred – reading from a region that should have been filled with call data but remained empty.

Optimization/Deduplication Oversights: The transpiler’s optimization passes likely removed or bypassed safety guards. The success-check for an external call’s return was effectively ignored. It’s plausible that a bounds-check if around the memory access was stripped out under a “maximum optimization” setting, given that such settings explicitly remove bounds checks. Furthermore, attempts to deduplicate identical helper functions or assembly patterns introduced coupling between logically separate parts of the code (for example, merging the callback parsing logic in a way that interfered with the fallback logic). This structural deduplication, while aiming to reduce code size, created unintended cross-links between the EOA trade path and the internal callback path.

Stack and Allocation Handling: Finally, subtle issues in resource handling (stack slots and memory pointers) might have contributed. If the compiler backend reused internal variables improperly or failed to preserve the free-memory pointer across an allocation, it could lead to losing data. The Venom backend does implement strategies to avoid pointer loss, but any lapse in those strategies (or an unforeseen interaction in this complex function) could cause a pointer like expr_mpos to remain at zero or be overwritten prematurely. This would directly feed into the ghost array problem.

Overall, the Panic 0x32 was the symptom of transpiler-generated code that violated high-level invariants: an external call’s result was used without checking success, a dynamic array was accessed without ensuring it was populated, and two distinct execution flows became entangled. The combination of a broken dispatcher, improper memory initialization, and overzealous optimization/deduplication created a “perfect storm” in the GuardedTrader’s transpiled bytecode. Each of these issues underscores critical areas for the yul2venom transpiler and Venom backend to address – ensuring branch conditions remain correct, scoping memory uses to valid ranges, and being cautious with function deduplication across different contexts. The investigation thus highlights how a complex fallback/dispatcher can go awry when compiler internals don’t carefully honor the original program logic, leading to severe runtime errors.

Sources: The GuardedTrader’s fallback design, yul2venom optimization docs, and Venom IR builder comments were used to corroborate these findings.